# Вопросы с собеседований на вакансию Unity developer

## Вопросы о движке Unity

### Junior

1. ***Что такое drawcall, batching?***

**Ответ:** drawcall - команда графическому API (OpenGL или DirectX). batching - объединение объектов во время исполнения, чтобы рисовать их вместе в рамках одного drawcall.

2. ***В каком порядке вызываются события MonoBehaviour в процессе рендеринга кадра?***

**Ответ:** Awake() -> OnEnable() -> Start() -> FixedUpdate() -> Update() -> LateUpdate() -> OnDisable -> OnDestroy().

3. ***В какой момент вызывается метод Awake()?***

**Ответ:** вызывается до начала любых функций, а также сразу после инициализации префаба.

4. ***В какой момент вызывается метод OnEnable()?***

**Ответ:** Функция вызывается сразу после включения объекта

5. ***В какой момент вызывается метод Start()?***

**Ответ:** Вызывается до обновления первого кадра(first frame) только если скрипт включен.

6. ***В какой момент вызывается метод FixedUpdate()?***

**Ответ:** Используют рассчета физики объекта.

7. ***В какой момент вызывается метод Update()?***

**Ответ:** Вызывается раз за кадр.

8. ***В какой момент вызывается метод LateUpdate()?***

**Ответ:** Используют для преследующей камеры от третьего лица. 

9. ***В какой момент вызывается метод OnDisable()?***

**Ответ:** Вызывается, когда объект отключается или становится неактивным.

10. ***В какой момент вызывается метод OnDestroy()?***

**Ответ:** Вызывается после всех обновлений кадра в последнем кадре объекта, пока он ещё существует.

11. ***Какие существуют функции преобразования из локальных координат в мировые и обратно (для точки и для направления)?***

**Ответ:** InverseTransformPoint(Vector3 position) - преобразует позицию из мировой в локальную систему координат. Противоположно TransformPoint(Vector3 position).
InverseTransformDirection(Vector3 direction) - преобразовывает направление из глобальной в локальную систему координат. Противоположно TransformDirection(Vector3 direction).

12. ***Что такое MonoBehaviour?***

**Ответ:** Базовый класс, от которого наследуются все скрипты.


## Вопросы о языке С#

### Junior
1. ***На каких принципах основывается ООП?***

**Ответ:** Объектно-ориентированное программирование основывается на понятиях абстракции, инкапсуляции, полиморфизма и наследования. Классы реализуют эти концепции для построение объектов, контролирующих или реализующих систему.

2. ***Какие типы можно использовать в предложении foreach?***

**Ответ:** Массивы, коллекции. Классы в которых реализован интерфейс System.Collections.IEnumerable.

3. ***В чем различие между классом и структурой?***

**Ответ:** Для С# классы - это ссылочные типы (память выделяется из куче). Cтруктуры и перечисления являются типами значений (хранятся обычно в стеке, но могут быть встроены в ссылочные типы). При объявлении переменных без идентификатора доступа в классе будут иметь значение private, в структуре значение public.

4. ***Что означает модификатор virtual?***

**Ответ:** При наследовании класса. Данный метод м.б. переопределен в производных классах с помощью ключевого слова override.

5. ***Чем отличается event от delegate?***

**Ответ:** delegate — это класс, содержащий в себе «шаблон» метода, то есть, сигнатуру метода. Переменная делегатного типа — объект типа MulticastDelegate (точнее, производного от него), который может содержать один или несколько объектов, представляющих собой методы с совместимой с «шаблоном» сигнатурой (контр- и ковариантность немного усложняет картину). То есть это как бы переменная, которая может содержать функции. Для таких переменных определена операция +, которая комбинирует слагаемые-функции в одну новую функцию, и симметричная операция -. Эти операции автоматически порождают производные операции += и -=.
event же — это просто пара методов в классе, обозначаемых как add и remove, и имеющих произвольную семантику, выбранную программистом. (Аналог — геттер и сеттер свойства.) В имплементации по умолчанию для event'а заводится скрытое поле делегатного типа, а add/remove добавляют или убирают из него методы (под lock'ом). (Чтобы немного запутать картину, это скрытое поле доступно по тому же имени, что и event.) Функции add/remove, составляющие event, вызываются соответственно как += и -=. Никаких операций +/-, разумеется, нету.
Delegate – это указатель на функцию. Делегаты допускают передачу методов в качестве параметров. Делегаты можно использовать для определения методов обратного вызова. Делегаты можно связывать друг с другом; например, при появлении одного события можно вызывать несколько методов.
В С# модель издатель — подписчик, где класс публикует событие, которое он может инициировать, и любые классы могут подписаться на это событие. Метод, вызываемый при возникновении события, определяется делегатом. Событие — это тот же самый делегат, который наделяется некоторыми свойствами через слово event.

6. ***Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы?***

**Ответ:** Да.

7. ***В чем разница инкапсуляции и сокрытия?***

**Ответ:** Инкапсуляция предполагает формирование классов, т.е. размещение в одном месте сразу и структур данных, и методов. Инкапсуляция также предполагает установку области видимости структур данных и методов от использования их вне класса, в частности сокрытие данных и методов использую private.

8. ***Поддерживает ли C# множественное наследование?***

**Ответ:** С# поддерживает множественное наследование в виде наследования от класса и нескольких интерфейсов, или просто от нескольких интерфейсов. Но не поддерживает наследование от нескольких классов. 

9. ***Кому доступны переменные с модификатором protected на уровне класса?***

**Ответ:** Любому классу-наследнику.

10. ***Назовите класс .NET, от которого наследуются все классы?***

**Ответ:** System.Object.

11. ***Что обозначает термин immutable (неизменяемый)?***

**Ответ:** Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены. Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти.

12. ***Как отсортировать элементы массива в убывающем порядке?***

**Ответ:** Нужно вызвать метод Sort(), а затем метод Reverse().

13. ***Будет ли выполнен блок finally, если не было сгенерировано исключение?***

**Ответ:** Да.

14. ***Можно ли запретить наследование от своего собственного класса?***

**Ответ:** Да. Для этого служит ключевое слово “sealed”.

15. ***Что такое абстрактный класс?***

**Ответ:** Это класс, объект которого не может быть создан. Такой класс должен иметь класс-наследник с реализацией абстрактных методов. Абстрактный класс – это фактически чертёж нормального класса без реализации.

16. ***В каком случае вы обязаны объявить класс абстрактным?***

**Ответ:** В том случае, если класс является наследником абстрактного класса, но не все методы базового класса перекрыты и имеют реализацию. В том случае, если хотя бы один метод класса является абстрактным.

17. ***Что такое интерфейс класса?***

**Ответ:** Интерфейсы, как и классы, определяют набор свойств, методов и событий. Но, в отличие от классов, они не содержат их реализации. Интерфейсы реализуются классами и определяются как самостоятельные сущности.

18. ***Почему нельзя указать модификатор видимости для методов интерфейса?***

**Ответ:** Потому что все они должны иметь модификатор public, который и установлен по умолчанию.

19. ***Назовите отличия между интерфейсом и абстрактным классом?***

**Ответ:** В интерфейсе все методы (свойства и т.д.) абстрактны и не имеют реализации. В абстрактном классе некоторые методы могут быть реализованы. В интерфейсе члены не могут иметь модификатора видимости (все они являются public по умолчанию), а в абстрактном классе члены могут иметь модификатор видимости.

20. ***Что обозначает принцип инкапсуляция?***

**Ответ:** Это совмещение структур данных с функциями (методами), манипулирующими этими данными. Фактически, инкапсуляция предполагает размещение в одном месте сразу и структур данных, и методов.

21. ***Что обозначает принцип наследование?***

**Ответ:** Создание новых классов, которые строятся на базе структур данных и методов уже существующих классов (базовых).

22. ***Что обозначает принцип наследование?***

**Ответ:** Использование одного имени или идентификатора для метода внутри одной иерархии класса таким образом, чтобы для разных классов этой иерархии этот метод реализовывал различные операции. 

23. ***Что обозначает принцип абстракция?***

**Ответ:** Позволяет уменьшить связывание между компонентами пердоставляя дополнительный слой между ними, для того чтоб один объект не зависил от того, как другой реализуюет свои бизнес-правила. (Интерфейсы, слои)

24. ***Назовите явное имя параметра, передаваемого в метод set свойства класса?***

**Ответ:** value. Тип этого параметра определяется типом свойства.

25. Чем перекрытый метод отличается от перегруженного метода?

**Ответ:** При перекрывании метода мы изменяем его поведение в классе наследнике. Перегрузка метода просто приводит к использованию другого метода с тем же именем внутри класса.

26. ***Какими способами может быть перегружен метод?***

**Ответ:** Другой тип параметров, другое количество параметров, другой порядок параметров. Фактически всё может быть другим, кроме имени.

27. ***Когда объект удаляется сборщиком мусора?***

**Ответ:** Объект удаляется сборщиком мусора, когда на него не остается ссылок.

28. ***Что такое attribute?***

**Ответ:** Универсальное средство связи данных с типами, позволяют добавлять любую текстовую информацию о классах, свойствах, методах и т.д. Атрибуты сохраняются с метаданными и могут быть получены при выполнении программы ([Serializable], [NonSerialized]).

29. ***As, is – что это, как применяется?***

**Ответ:** С помощью оператора as программа пытается преобразовать выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение null.

30. ***Что обозначает объявление класса static?***

**Ответ:** Нельзя создавать экземпляры статического класса.


### Middle

1. ***Есть следующие объявления классов A и B:***
```
class A
{
    public virtual void Foo()
    {
        Console.Write("Class A");
    }
}
class B: A
{
    public override void Foo()
    {
        Console.Write("Class B");
    }
}
```
Что выведут на консоль такие вызовы метода Foo():
```
B obj1 = new A();
obj1.Foo();
 
B obj2 = new B();
obj2.Foo();
 
A obj3 = new B();
obj3.Foo();
```
**Ответ:** Первое выражение выдаст ошибку downcast (использовать преобразовании от базового к производному). Второе и третье выражение выдаст Class B.

2. ***Что будет выведено на консоль в результате следующих операций:***
```
int i = 1;
object obj = i;
++i;
Console.WriteLine(i);
Console.WriteLine(obj);
Console.WriteLine((short)obj);
```
**Ответ:** В пером случае будет ответ 2, во втором 1 (так как сделали Boxing), ошибка.

3. ***Является ли тип List потокбезопасной (thread-safe) коллекцией?***

**Ответ:** Если речь идет только о чтение коллекции без изменения, то это потокобезопасно, но если оценивать в целом, то List не потокобезопасен даже во время чтения.

4. ***В чем различие между операцией cast (приведения типов) и оператором as?***

**Ответ:** Выражение «as» всегда возвращает указанный тип, так что он должен быть типом, допускающим null. Cast бросает исключение при неуспехе преобразования, а as возвращает null.

5. ***Какова алгоритмическая сложность для операций чтения и записи для коллекции Dictionary?***

**Ответ:** Чтение - О(1), запись - О(n)

6. ***В чем различие между ключевыми словами ref и out?***

**Ответ:** Параметр с ключевым слово out может быть не инициализирован, а параметр с ключевым словом ref обязательно должен быть инииализирован до вызова метода, который использует эти параметры.

7. ***В чем отличие необязательных параметров от именованных?***

**Ответ:** Именованные параметры: Именованные аргументы освобождают разработчика от необходимости запоминать или уточнять порядок параметров в списках параметров вызванных методов. Параметр для каждого аргумента можно указать, используя имя параметра.
```PrintOrderDetails(productName: "Red Mug", sellerName: "Gift Shop", orderNum: 31);```
Необязательные параметры: Определение каждого необязательного параметра содержит его значение по умолчанию. Если аргумент для параметра не передается, используется значение по умолчанию. Значением по умолчанию должен быть один из следующих типов выражений:константное выражение;выражение в форме new ValType(), где ValType — это тип значения, например, enum или struct; выражение в форме default(ValType), где ValType — это тип значения.
```void ExampleMethod(int required, string optionalstr = "default string", int optionalint = 10)```

8. ***Чем отличаются друг от друга классы String и StringBuilder? Зачем нужно такое разделение?***

**Ответ:** Уникальным в StringBuilder является то, что при вызове его членов производится непосредственное изменение внутренних символьных данных объекта (что, конечно же, более эффективно), а не получение копии этих данных в измененном формате (как в String). При создании экземпляра StringBuilder начальные значения для объекта можно задавать с помощью не одного, а нескольких конструкторов.

9. ***Как и зачем использовать оператор Using в C#?***

**Ответ:** Ключевое слово Using упрощает работу с объектами которые реализуют интерфейс IDisposable. Интерфейс IDisposable содержит один метод .Dispose(), который используется для освобождения ресурсов, которые захватил объект. При использовании Using не обязательно явно вызывать .Dispose() для объекта. Using блоки делают код более читабельным и компактным.
```using (SqlConnection conn = new SqlConnection()) { // какая-нибудь SQL операция } ```
Аналогично: ```SqlConnection conn = new SqlConnection(); try { } finally { // здесь для conn вызывается .Dispose()}``` 

10. ***В чем отличие использования Finalize и Dispose?***

**Ответ:** Метод Dispose - это использование паттерна RAII (получение ресурса есть инициализация). Например, открытый файл, сетевой сокет или соединение с базой данных нужно в конце работы закрыть. В языках без сборки мусора вроде C++ полученный ресурс освобождается деструктором, т.к. программист вызывает его вручную. В C# же деструктор (т.е. метод Finalize) вызывается сборщиком мусора автоматически в неопределенное время, может быть даже не вызван вообще. Поэтому чтобы освобождать ресурс вручную, если он больше не нужен и придумали интерфейс IDisposable с методом Dispose, а также оператор using.

11. ***Как можно сравнить строки в C#?***

**Ответ:** В прошлых версиях C# нужно было вызывать у строки .ToString() и использовать операторы != и == для сравнения. Это работает и до сих пор, но компилятор C# сейчас автоматически сравнивает строки по значению, а не по ссылке, при использовании операторов == или != на значениях строкового типа. Если же необходимо сравнить строки по ссылке, это следует делать так: if ((Object) s1 == (Object) s2) {}.

12. ***Что такое управляемый код и CLR?***
**Ответ:** Управляемый код — термин, введённый фирмой Microsoft, для обозначения кода программы, исполняемой под «управлением» виртуальной машины. NET — Common Language Runtime или Mono.

13. ***Что такое IoC(Inversion of Control) и для чего он(принцип) нужен?***

**Ответ:** Инверсия управления (IoC, Inversion of Control) – это достаточно общее понятие, которое отличает библиотеку от фреймворка. Классическая модель подразумевает, что вызывающий код контролирует внешнее окружение и время и порядок вызова библиотечных методов. Однако в случае фреймворка обязанности меняются местами: фреймворк предоставляет некоторые точки расширения, через которые он вызывает определенные методы пользовательского кода.

14. ***Что подразумевается под свойствами в C#?***

**Ответ:** Свойство выступает как двунаправленная связь между полем и методом. Вообще говоря, свойство ведет себя как поле. С помощью свойства можно получать/заносить данные в поле. Компилятор автоматически преобразует обращение к свойству в вызов специального метода, который называют accessor (метод доступа). Есть 2 метода доступа к свойству: get (для получения значения) и set (для занесения значения). Исходя из этого, использование свойств делится на три типа:
свойство ReadOnly - есть только метод доступа get
свойство WriteOnly - есть только метод доступа set
свойство ReadWrite - есть оба метода доступа

15. ***Что такое Boxing и Unboxing?***

**Ответ:** Boxing: ```int i = 123; object o = i;``` Упаковка используется для хранения типов значений в куче со сбором мусора. Упаковка представляет собой неявное преобразование типа значения в тип object или в любой другой тип интерфейса, реализуемый этим типом значения. При упаковке типа значения в куче выделяется экземпляр объекта и выполняется копирование значения в этот новый объект.
Unboxing: ```o = 123; i = (int)o;``` Распаковка является явным преобразованием из типа object в тип значения или из типа интерфейса в тип значения, реализующего этот интерфейс. Операция распаковки состоит из следующих действий: проверка экземпляра объекта на то, что он является упакованным значением заданного типа значения; копирование значения из экземпляра в переменную типа значения.

16. ***В чём разница между System.Array.CopyTo() и System.Array.Clone()?***

**Ответ:** Первый метод копирует не только сами элемента класса Array, но и всякие объекты, которые связаны ссылками с этими элементами Array. Это всё называется "глубоким копированием".
Второй метод осуществляет так называемое "поверхностное копирование". При поверхностном копировании метод копирует только элементы объекта класса Array, и методу не важно, являются ли эти элементы value или reference типами. Копирование объектов которые связаны какими-то ссылками не происходит, а сами ссылки коируются так же, как и в оригинальном Array.

17. ***Чем отличаютя константы и поля, доступные только для чтения?***

**Ответ:** Константы должны быть определены во время компиляции, а поля для чтения могут быть определены во время выполнения программы. Соответственно инициализировать константу можно устанновить только при ее определении. Поле для чтения можно инициализировать либо при его определении, либо в конструкторе класса. Константы не могут использовать модификатор static, так как уже неявно являются статическими. Поля для чтения могут быть как статическими, так и не статическими.


## Задачи


## Архитектура
